= Spring Cloud AWS
Agim Emruli; Alain Sahli

include::intro.adoc[]

== Using Amazon Webservices

Amazon provides a http://aws.amazon.com/sdk-for-java/[Java SDK] to issue requests for the all services provided by
http://aws.amazon.com[Amazon Webservice] platform. Using the SDK, application developers still have to integrate the
SDK into their application with an considerable amount of infrastructure related code. Spring Cloud AWS provides application
 developers already integrated Spring-based modules to consume service and avoid infrastructure related code as much as possible.
 The Spring Cloud AWS module provides a module set so that application developer can arrange the dependencies based on
 their needs for the particular services. The graphics provides a general overview of all Spring Cloud AWS modules along
 with the service support for the respective Amazon Cloud AWS services.

image::overview.png[Overview]

* *Spring Cloud AWS Core* is the core module of Spring Cloud AWS providing basic service for security and configuration
setup. Developers will not use this module directly but rather through other modules. The core module provides support for
cloud based environment configurations providing direct access to the instance based http://aws.amazon.com/ec2/[EC2]
meta-data and the overall application stack specific http://aws.amazon.com/cloudformation/[CloudFormation] meta-data.
* *Spring Cloud AWS Context* delivers access to the http://aws.amazon.com/s3/[Simple Storage Service] via the Spring
resource loader abstraction. Also developers can send E-Mail using the http://aws.amazon.com/ses/[Simple E-Mail Service]
and the Spring mail abstraction. Further the developers can introduce declarative caching using the Spring caching support
and the http://aws.amazon.com/elasticache/[Elasticache] caching service.
* *Spring Cloud AWS JDBC* provides automatic data source lookup and configuration for the http://aws.amazon.com/rds/[Relational Database Service]
which can be used with JDBC or any other support data access technology by Spring.
* *Spring Cloud AWS Messaging* enables developers to receive and send messages with the http://aws.amazon.com/sqs/[Simple Queueing Service] for
point-to-point communication. Publish-subscribe messaging is supported with the integration of the http://aws.amazon.com/sns/[Simple Notification Service]

== Basic setup
Before using the Spring Cloud AWS module developers have to pick the dependencies and configure the Spring Cloud AWS module.
The next chapters describe the dependency management and also the basic configuration for the Spring AWS Cloud project.

=== Spring Cloud AWS maven dependency management
Spring Cloud AWS module dependencies can be used directly in Maven[http://maven.apache.org] with a direct configuration
of the particular module. The Spring Cloud AWS module includes all transitive dependencies for the Spring modules and
also the Amazon SDK that are needed to operate the modules. The general dependency configuration will look like this:

[source,xml,indent=0]
----
<dependencies>
  <dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-aws-context</artifactId>
    <version>1.0.0.RELEASE</version>
  </dependency>>
</dependencies>
----

Different modules can be included by replacing the module name with the respective one (e.g. _spring-cloud-aws-messaging_
instead of _spring-cloud-aws-context_)


The example above works with the Maven Central repository. To use the Spring Maven repository (e.g. for milestones or
developer snapshots), you need to specify the repository location in your Maven configuration. For full releases:

[source,xml,indent=0]
----
<repositories>
    <repository>
        <id>io.spring.repo.maven.release</id>
        <url>http://repo.spring.io/release/</url>
        <snapshots><enabled>false</enabled></snapshots>
    </repository>
</repositories>
----

For milestones:

[source,xml,indent=0]
----
<repositories>
    <repository>
        <id>io.spring.repo.maven.milestone</id>
        <url>http://repo.spring.io/milestone/</url>
        <snapshots><enabled>false</enabled></snapshots>
    </repository>
</repositories>
----

=== Amazon SDK configuration
The Spring Cloud AWS configuration is currently done using custom elements provided by Spring Cloud AWS namespaces. Java
configuration support will be supported soon. The configuration setup is done directly in Spring XML configuration files
so that the elements can be directly used. Each module of Spring Cloud AWS provides custom namespace to allow the modular
use of the modules. A typical XML configuration to use Spring Cloud AWS is outlined below:


[source,xml,indent=0]
----
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aws-context="http://www.springframework.org/schema/cloud/aws/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/cloud/aws/context
        http://www.springframework.org/schema/cloud/aws/context/spring-cloud-aws-context-1.0.xsd">

           <aws-context:context-region region="..."/>
</beans>
----

==== SDK credentials configuration
In order to make calls to the Amazon Webservice the credentials must be configured for the the Amazon SDK. Spring Cloud AWS
provides support to configure an application context specific credentials that are used for _each_ service call for request done
by Spring Cloud AWS components. Therefore there must be *exactly one* configuration of the credentials for an entire application
context.

Based on the overall credentials policy there are different options to configure the credentials. The possible ones are described in
the following sub-chapters.

===== Simple credentials configuration
Credentials for the Amazon SDK consist of an access key (which might be shared) and a secret key (which must *not* be shared). Both
 security attributes can be configured using the XML namespaces for each Amazon SDK service created by the Spring Cloud AWS
 module. The overall configuration looks like this

[source,xml,indent=0]
----
<beans ...>
  <aws-context:context-credentials>
   <aws-context:simple-credentials access-key="AKIAIO" secret-key="wJalrXUtnFEMI/K7M" />
  </aws-context:context-credentials>
</beans>
----

[CAUTION]
====
The access-key and secret-key should be externalized into property files (e.g. Spring Boot application configuration) files
and not be checked in into the source management system.
====

===== Instance profile configuration
An http://docs.aws.amazon.com/IAM/latest/UserGuide/instance-profiles.html[instance profile configuration] allows to assign
 a profile that is authorized by a role while starting an EC2 instance. All calls made from the EC2 instance are then authenticated
 with the instance profile specific user role. Therefore there is no dedicated access-key and secret-key needed in the configuration.
The configuration for the instance profile in Spring Cloud AWS looks like this:

[source,xml,indent=0]
----
<beans ...>
	<aws-context:context-credentials>
 		<aws-context:instance-profile-credentials/>
 	</aws-context:context-credentials>
</beans>
----

===== Mixing both security configurations
In some cases it is useful to combine both authentication strategies to allow the application to use the instance profile
with a fallback for an explicit access-key and secret-key configuration. This is useful if the application is tested inside
EC2 (e.g. on a test server) and locally for testing. The next snippet shows a combination of both security configurations.

[source,xml,indent=0]
----
 <beans ...>
    <aws-context:context-credentials>
        <aws-context:instance-profile-credentials/>
        <aws-context:simple-credentials access-key="${accessKey:}" secret-key="${secretKey:}"/>
    </aws-context:context-credentials>
 </beans>
----

[TIP]
====
The access-key and secret-key are defined using a placeholder expressions along with a default value to avoid bootstrap
 errors if the properties are not configured at all.
====

==== Region configuration
Amazon Webservices are available in different http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html[Regions]. Based
on the custom requirements, the user can host the application on different Amazon regions. The Spring Cloud AWS module provides
a general application context wide configuration for the region.

===== Explicit region configuration
The region can be explicitly configured using a XML element. This is particularly useful if the region can not be automatically
derived because the application is not hosted on a EC2 instance (e.g. local testing) or the region must be manually overridden.

[source,xml,indent=0]
----
<beans ...>
  	<aws-context:context-region region="EU_WEST_1"/>
</beans>
----

[TIP]
====
It is also allowed to use expressions or placeholders to externalize the configuration and ensure that the region can
be reconfigured with property files or system properties.
====

===== Automatic region configuration
If the application context is started inside an EC2 instance, then the region can be automatically be fetched from the
http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html[instance meta-data] and therefore must
not be configured. The configuration will look like this:

[source,xml,indent=0]
----
   <beans ...>
     <aws-context:context-region auto-detect="true" />
   </beans>
----

===== Service specific region configuration
A region can also be overridden for particular services if one application context consumes service from different regions.
The configuration can be done globally like described above and configured for each service with an region attribute.
The configuration might look like this for an database service (described later)

[source,xml,indent=0]
----
 <beans ...>
  <aws-context:context-region region="EU_CENTRAL_1" />
  <jdbc:dataSource ... region="EU_WEST_1" />
 </beans>
----

[NOTE]
====
While it is theoretically possible to use multiple regions per application, we strongly recommend to write application that
 are hosted only inside one region and split the application if it is hosted in different regions at the same time.
====

== Cloud environment
Application often need environment specific configuration information, especially in changing environments like in the
Amazon cloud environment. Spring Cloud AWS provides an support to retrieve and use environment specific data inside the
application context using common Spring mechanisms like property placeholder or the Spring expression language.

=== Retrieving instance meta-data
http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html[Instance meta-data] are available inside an
EC2 environment. The meta-data can be queried using a special HTTP address that provides the instance meta-data. Spring Cloud
 AWS enables application to access this meta-data directly in expression or property placeholder without the need to call
 an external HTTP service.

==== Enabling instance meta-data support
The instance meta-data retrieval support is enabled through an XML element like the standard property placeholder in Spring.
The following code samples demonstrates the activation of the instance meta-data support inside an application context.

[source,xml,indent=0]
----
   <beans ...>
     	<aws-context:context-instance-placeholder />
   </beans>
----

[TIP]
====
Instance meta-data can be retrieved without an authorized service call, therefore the configuration above does not require
any region or security specific configuration.
====

==== Using instance meta-data
Instance meta-data can be used in XML and Java placeholders and expression. The example below demonstrates the usage of
instance meta-data inside an XML file using placeholder and also the expression referring to the special variable _environment_

[source,xml,indent=0]
----
<beans ...>
 <bean class="org.springframework.cloud.aws....SimpleConfigurationBean">
	<property name="value1" value="#{environment.ami-id}" />
	<property name="value2" value="#{environment.hostname}" />
	<property name="value3" value="${instance-type}" />
	<property name="value4" value="${instance-id}" />
 </bean>
</beans>
----

Instance meta-data can also be injected with the Spring _org.springframework.beans.factory.annotation.Value_ annotation
directly into Java fields. The next example demonstrates the use of instance meta-data inside a Spring bean.

[source,java,indent=0]
----
   @Component
   public class ApplicationInfoBean {

       @Value("${ami-id:N/A}")
       private String amiId;

       @Value("${hostname:N/A}")
       private String hostname;

       @Value("${instance-type:N/A}")
       private String instanceType;

       @Value("${services/domain:N/A}")
       private String serviceDomain;
   }

----

[NOTE]
====
Every instance meta-data can be accessed by the key available in the http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html[instance meta-data service]
Nested properties can be accessed with by separating the properties with a slash ('/').
====

==== Using instance user-data
Besides the default instance meta-data it is also possible to configure user-data on each instance. This user-data is retrieved and
parsed by Spring Cloud AWS. The user-data can be defined while starting an EC2 instance with the application. Spring Cloud AWS
expects the format <key>:<value>;<key>:<value> inside the user data so that it can parse the string and extract the key value pairs.

The user-data can be configured either using the management console shown below or a http://aws.amazon.com/cloudformation/aws-cloudformation-templates/[CloudFormation template]

image::cloud-environment-user-data.png[User data in the management console]


A CloudFormation for the configuration of the user data is outlined below

[source,json,indent=0]
----
   ...
   "Resources": {
    "ApplicationServerInstance": {
   	 "Type": "AWS::EC2::Instance",
   	 "Properties": {
   	  "ImageId": "ami-6a56b81d",
   	  "UserData": {
   	     "Fn::Base64": "data1=value1;data2=value2"
   	   },
   	  "InstanceType": "t1.micro",
   	 }
   }
   ...

----

The user data can be accessed directly in the application context like the instance meta-data through placeholders
or expressions.

[source,java,indent=0]
----
@Component
public class SecondConfigurationBean {

	@Value("${data1}")
	private String firstDataOption;

	@Value("${data2}")
	private String secondDataOption;
}
----

[NOTE]
====
User-data stored in a base 64 encoded representation and automatically translated by Spring Cloud AWS
====

==== Using instance tags
User configured properties can also be configured with tags instead of user data. Tags are a global concept in the context
 of Amazon Webservices and used in different services. Spring Cloud AWS support instance tags also across different
 services. Compared to user data, user tags can also be updated during runtime, there is no need to stop and restart
 the instance.

[TIP]
====
http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html[User-data] can also be used to execute scripts
on instance startup. Therefore is it useful to leverage instance tags for user configuration and user data to script
 the instance startup.
====

Instance specific tags can be configured on the instance level through the management console outlined below and
like user data also with a CloudFormation template shown afterwards.

image::cloud-environment-instance-tags.png[Instance data in the management console]

A CloudFormation for the configuration of the instance tags is outlined below


[source,json,indent=0]
----
   ...
"Resources": {
	"UserTagAndUserDataInstance": {
		"Type": "AWS::EC2::Instance",
		"Properties": {
			"ImageId": "ami-6a56b81d",
		  	"InstanceType": "t1.micro",
		  	"Tags": [
			{
				"Key": "tag1",
			  	"Value": "tagv1"
			},
			{
				"Key": "tag3",
			  	"Value": "tagv3"
			},
			{
				"Key": "tag2",
			  	"Value": "tagv2"
			},
			{
				"Key": "tag4",
				"Value": "tagv4"
			}
			]
		}
	}
}
----

To retrieve the instance tags, Spring Cloud AWS has to make authenticated requests and therefore it will need the region
and security configuration before actually resolving the placeholder. Also because the instance tags are not available while starting
 the application context, they can be only referenced as expression and not with placeholders. The _context-instance-placeholder_
 element defines an attribute _user-tags-map_ that will create a map in the application context for the name. This map
 can then be queried using expression for other bean definitions.

[source,xml,indent=0]
----
 <beans ...>
  <aws-context:context-instance-placeholder user-tags-map="instanceData" />
 </beans>
----

A java bean might resolve expression with the _@Value_ annotation.

[source,java,indent=0]
----
 public class SimpleConfigurationBean {

 	@Value("#{instanceData.tag1}")
 	private String value1;
 	@Value("#{instanceData.tag2}")
 	private String value2;
 	@Value("#{instanceData.tag3}")
 	private String value3;
 	@Value("#{instanceData.tag4}")
 	private String value4;
 }
----

==== Configuring custom EC2 client
In some circumstances it is necessary to have a custom EC2 client to retrieve the instance information. The
_context-instance-placeholder_ element support custom EC2 client with the _amazon-ec2_ attribute. The next
example shows the use of a custom EC2 client that might have a special configuration in place

[source,xml,indent=0]
----
<beans ...>

  <aws-context:context-credentials>....</aws-context:context-credentials>
  <aws-context:context-region ... />
  <aws-context:context-instance-placeholder  amazon-ec2="myCustomClient"/>

  <bean id="myCustomClient" class="com.amazonaws.services.ec2.AmazonEC2Client">
	...
  </bean>
</beans>
----

==== Injecting the default EC2 client
By default Spring Cloud AWS configures an EC2 client with the specified region and security credentials. Application
 developers can inject the EC2 client directly into their code using the _@Autowired_ annotation.

[source,java,indent=0]
----
public class ApplicationService {

	private final AmazonEC2 amazonEc2;

	@Autowired
	public ApplicationService(AmazonEC2 amazonEc2) {
		this.amazonEc2 = amazonEc2;
	}
}
----

== Managing cloud environments
Managing environment manually with the management console does not scale and can become error-prone with the increasing
complexity of the infrastructure. Amazon Webservices offers a http://aws.amazon.com/cloudformation/[CloudFormation]
services that allows to define stack configuration templates and bootstrap the whole infrastructure with the service.
In order to allow multiple stack in parallel, each resource in the stack receive a unique physical name that contains
some arbitrary generated name. In order to interact with the stack resource in a unified way Spring Cloud AWS allows
developers to work with logical names instead of the random physical ones.

The next graphics shows a typical stack configuration

image::cloudformation-overview.png[CloudFormation overview]

The *Template File* describes all stack resources with their _logical name_. The *CloudFormation* services parses the stack
template file and creates all resources with they _physical name_. The application can use all the stack configured resources
with the _logical name_ defined in teh template. Spring Cloud AWS resolves all _logical names_ into the respective
_physical name_ for the application developer.

=== Automatic CloudFormation configuration
If the application runs inside a stack (because the underlying EC2 instance has been bootstrapped within the stack), then
the Spring Cloud AWS will automatically detect the stack and resolve all resources from the stack. Application developers
can use all the logical names from the stack template to interact with the services. In the example below, the database
resource is configured using CloudFormation template, defining a logical name for the database instance.

[source,xml,indent=0]
----
"applicationDatabase": {
  "Type": "AWS::RDS::DBInstance",
  "Properties": {
  	"AllocatedStorage": "5",
  	"DBInstanceClass": "db.t1.micro",
  	"DBName": "test"
  	...
  ]
 }
}
----

The datasource is then created and will receive a physical name (e.g. ir142c39k6o5irj) as the database service name. Application
 developers can still use the logical name (in this case _applicationDatabase_) to interact with the database. The example shows
 the stack configuration which is defined by the element _aws-context:stack-configuration_ and resolves automatically the
 particular stack. The _dataSource_ element uses the logical name for the _db-instance-identifier_ attribute to work with
 the database.

[source,xml,indent=0]
----
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:aws-context="http://www.springframework.org/schema/cloud/aws/context"
	   xmlns="http://www.springframework.org/schema/beans"
	   xsi:schemaLocation="http://www.springframework.org/schema/cloud/aws/context
	   http://www.springframework.org/schema/cloud/aws/context/spring-cloud-aws-context-1.0.xsd">

  <aws-context:context-credentials>
  	...
  </aws-context:context-credentials>

  <aws-context:context-region .. />

  <aws-context:stack-configuration/>

  <jdbc:dataSource id="dataSource" db-instance-identifier="RdsSingleMicroInstance" ... />
</beans>
----

[TIP]
====
Further detailed information on the Amazon RDS configuration and setup can be found in the respective chapter in this
documentation.
====


=== Manual CloudFormation configuration
If the application is not running inside an stack configured EC2 instance, then the stack configuration must be configured
manually. The configuration consistent of an additional element _stack-name_ attribute that will be used to resolve all the
respective stack configuration information at runtime.

[source,xml,indent=0]
----
<beans ....>
	...
  <aws-context:stack-configuration stack-name="myStackName" />
    ...
</beans>
----

=== Manual name resolution
Spring Cloud AWS uses the CloudFormation stack to resolve all resources internally using the logical name. In some circumstances
it might be needed to resolve the physical name inside the application code. Spring Cloud AWS provides a pre-configured
service to resolve the physical stack name based on the logical name. The sample shows a manual stack resource resolution.

[source,java,indent=0]
----
@Service
public class ApplicationService {

 private final ResourceIdResolver resourceIdResolver;

 @Autowired
 public ApplicationService(ResourceIdResolver resourceIdResolver) {
 	this.resourceIdResolver = resourceIdResolver;
 }

 public void handleApplicationLogic() {
 	String physicalBucketName =
 		this.resourceIdResolver.resolveToPhysicalResourceId("someLogicalName");
 }
}
----

=== Stack Tags
Like for the Amazon EC2 instances, CloudFormation provides also Stack specific tags that can be used to
configure stack specific configuration information and receive them inside the application. This can be
for example a stage specific configuration property (like DEV, INT, PRD).

[source,xml,indent=0]
----
<beans ....>
	...
	<aws-context:stack-configuration user-tags-map="stackTags"/>
	...
</beans>
----

The application can then access the stack tags with a expression like _#{stackTags.key1}_

=== Using custom CloudFormation client
Like for the EC2 configuration setup, also the CloudFormation support for Spring Cloud AWS supports custom
client with a special setup. The client itself can be configured using the _amazon-cloud-formation_ attribute
as shown in the example:

[source,xml,indent=0]
----
<beans>
	<aws-context:stack-configuration amazon-cloud-formation=""/>

	<bean class="com.amazonaws.services.cloudformation.AmazonCloudFormationClient">
	</bean>
</beans>
----

== Data Access with JDBC

Spring has a broad support of data access technologies build on top of JDBC like the JdbcTemplate and dedicated ORM (JPA,
Hibernate support). Spring Cloud AWS enables application developers to re-use their JDBC technology of choice and access the
 http://aws.amazon.com/rds/[Amazon Relational Database Service] with a declarative configuration. The main support of Spring
 Cloud AWS for JDBC data access are

 * Automatic data source configuration and setup based on the Amazon RDS database instance
 * Automatic read-replica detection and configuration for Amazon RDS database instances
 * Retry-support to handle exception during Multi-AZ failover inside the data center

=== Configuring data source
Before configuring using and configuring the database support, the application has to include the respective module dependency
 into his maven configuration. Spring Cloud AWS JDBC support comes as a separate module to allow the modularized use of the
 modules.

==== Maven dependency configuration

The Spring Cloud AWS JDBC module comes as a standalone module and can be importet with the following dependency declaration

[source,xml,indent=0]
----
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-aws-jdbc</artifactId>
	<version>1.0.0.RELEASE</version>
</dependency>
----

==== Basic data source configuration
The data source configuration requires the security and region configuration as a minimum allowing Spring Cloud AWS to retrieve
 the database meta-data information with the Amazon RDS service. Spring Cloud AWS provides an additional _jdbc_ specific namespace
 to configure the data source with the minimum attributes as shown in the example:

[source,xml,indent=0]
----
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:jdbc="http://www.springframework.org/schema/cloud/aws/jdbc"
	   xmlns="http://www.springframework.org/schema/beans"
	   xsi:schemaLocation="http://www.springframework.org/schema/cloud/aws/jdbc
	   http://www.springframework.org/schema/cloud/aws/jdbc/spring-cloud-aws-jdbc-1.0.xsd">

 <aws-context:context-credentials>
  ...
 </aws-context:context-credentials>

 <aws-context:context-region region="..."/>

<jdbc:dataSource id="dataSource"
		 db-instance-identifier="myRdsDatabase"
		 password="${rdsPassword}">
</jdbc:dataSource>
</beans>
----

The minimum configuration parameters are an unique _id_ for the datasource, a valid _db-instance-identifier_ attribute
that points to a valid Amazon RDS database instance. The master user password for the master user. If there is another
 user to be used (which is recommended) then the _username_ attribute can be set.

With this configuration Spring Cloud AWS fetches all the necessary meta-data and creates a
http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html[Tomcat JDBC pool] with the default properties. The data source
can be later injected into any Spring Bean as shown below:

[source,java,indent=0]
----

@Service
public class SimpleDatabaseService implements DatabaseService {

 private final JdbcTemplate jdbcTemplate;

 @Autowired
 public SimpleDatabaseService(DataSource dataSource) {
 	this.jdbcTemplate = new JdbcTemplate(dataSource);
 }
}
----

It is possible to qualify the data source injection point with an _@Qualifier_ annotation to allow multiple data source
configurations inside one application context and still use auto-wiring.

==== Datasource pool configuration
Spring Cloud AWS creates a new Tomcat JDBC with the default properties. Often these default properties does not meet the
requirements of the application with regards to pool size and other settings. The data source configuration supports the configuration
of all valid pool properties with a nested XML element. The following example demonstrates the re-configuration of the data
source with custom pool properties.

[source,xml,indent=0]
----
<beans ..>

 <aws-context:context-credentials>
  ...
 </aws-context:context-credentials>

 <aws-context:context-region region="..."/>

 <jdbc:dataSource id="dataSource"
		 db-instance-identifier="myRdsDatabase"
		 password="${rdsPassword}">
		 <jdbc:pool-attributes initialSize="1" " maxActive="200" minIdle="10"
         		testOnBorrow="true" validationQuery="SELECT 1" />
 </jdbc:dataSource>

</beans>
----

A full list of all configuration attributes with their value is available http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html[here]

=== Read-replica configuration
Amazon RDS allows to use http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_ReadRepl.html[MySQL read-replica]
instances to increase the overall throughput of the database by offloading read data access to a one or many read-replica
slaves while maintaining the data in one master database.

Spring Cloud AWS supports the use of read-replicas in combination with Spring read-only transaction. If the read-replica
support is enabled, any read-only transaction will be routed to an read-replica instance while using the master database
for write operations.

[CAUTION]
====
Using read-replica instances does not guarantee strict http://en.wikipedia.org/wiki/ACID[ACID] semantics for the database
access and should by used with care. This is due to the fact that the read-replica might be behind and an write might not
be immediately visible to the read transaction. Therefore it is recommended to make only transaction read-only that read
data which is not changed very often and where outdated data can be handled by the application.
====

The read-replica support can be enabled with the _read-replica_ attribute in the data source configuration.

[source,xml,indent=0]
----
<beans ..>
 <jdbc:dataSource id="dataSource" db-instance-identifier="RdsSingleMicroInstance"
	password="${rdsPassword}" read-replica-support="true">

 </jdbc:dataSource>
</beans>
----

Spring Cloud AWS will search for any read-replica that is created for the master database and route the read-only transactions
to one of the read-replicas that are available. A business service that uses read-replicas can be implemented like shown
in the example.

[source,java,indent=0]
----
@Service
public class SimpleDatabaseService {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public SimpleDatabaseService(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate(dataSource);
	}

	@Transactional(readOnly = true)
	public Person loadAll() {
		// read data on the read replica
	}

	@Transactional
	public void updatePerson(Person person) {
		// write data into database
	}
}
----

=== Failover support
Amazon RDS support a http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZ.html[Multi-AZ] fail-over if
one availability zone is not available due to an outage or failure of the primary instance. The replication is synchronous
 (compared to the read-replicas) and provides continuous service. Spring Cloud AWS support a Multi-AZ failover with a retry
 mechanism to recover transactions that fail during a Multi-AZ failover

[NOTICE]
====
In most cases it is better to provide a user direct feedback instead of trying potentially long and often retires within
a user interaction. Therefore the fail-over support is primarily useful for batch application or application where the
responsiveness of an service call is not critical.
====

The Spring Cloud AWS JDBC module provides a retry interceptor that can be used to decorate services with an interceptor.
The interceptor will retry the database operation again if there is a temporary error due to an Multi-AZ failover. A Multi-AZ
failover typically lasts only a couple of seconds, therefore a retry of the business transaction will likely succeed.

The interceptor can be configured as a regular bean and then be used by an pointcut expression to decorate the respective
method calls with the interceptor. The interceptor must have a configured database to retrieve the current status (if it
is a temporary fail-over or a permanent error) from the Amazon RDS service.

The configuration for the interceptor can be done with a custom element from the Spring Cloud AWS jdbc namespace and
will be configured like shown:

[source,xml,indent=0]
----
<beans ..>
	<jdbc:retry-interceptor id="myInterceptor"
		db-instance-identifier="myRdsDatabase"
		max-number-of-retries="10" />
</beans>
----

The interceptor itself can be used with any Spring advice configuration to wrap the respective service. An pointcut
for the services shown in the chapter before can be defined as follows:

[source,xml,indent=0]
----
<beans ..>
 <aop:config>
  <aop:advisor advice-ref="myInterceptor" pointcut="bean(simpleDatabaseService)" order="1" />
 </aop:config>
</beans>
----

[CAUTION]
====
It is important the the interceptor is called outside the transaction interceptor to ensure that the whole transaction
will be re-executed. Configuring the interceptor inside the transaction interceptor will lead to a permanent error because
the broken connection will never be refreshed.
====

The configuration above in combination with a transaction configuration will produce the following proxy configuration
for the service.

image::jdbc-retry-interceptor.png[Retry interceptor]

=== Cloudformation support
Spring Cloud AWS support database instance that are configured with CloudFormation. Spring Cloud AWS can use the logical
name inside the database configuration and lookup the concrete database with the generated physical resource name. A data
base configuration can be easily configured in CloudFormation with a template definition that might look like the following
example.

[source,json,indent=0]
----
"myRdsDatabase": {
 	"Type": "AWS::RDS::DBInstance",
 	"Properties": {
 	 "AllocatedStorage": "5",
 	 "DBInstanceClass": "db.t1.micro",
 	 "DBName": "test",
 	 "Engine": "mysql",
 	 "MasterUsername": "admin",
 	 "MasterUserPassword": {"Ref":"RdsPassword"},
 	 ...
 	}
 },
 "readReplicaDatabase": {
 	"Type": "AWS::RDS::DBInstance",
 	"Properties": {
 	 "AllocatedStorage" : "5",
 	 "SourceDBInstanceIdentifier": {
 	 	"Ref": "myRdsDatabase"
 	 },
 	 "DBInstanceClass": "db.t1.micro"
 	}
 }
}
----

The database can then be configured using the name configured in the template, also the read-replica can
be enabled to use the configured read replica database in the application. A configuration to use the configured
database is outlined below:

[source,xml,indent=0]
----
<beans>
 <aws-context:stack-configuration/>
 <jdbc:dataSource id="dataSource" db-instance-identifier="myRdsDatabase" password="${rdsPassword}" read-replica-support="true"/>
</beans>
----

=== Database tags
Amazon RDS instance can also be configured using RDS database specific tags, allowing users to configure database specific
configuration meta-data with the database. Database instance specific can be configured using the _user-tags-map_ attribute
on the dataSource element. Configuring the tags support like in the example below:

[source,xml,indent=0]
----
	<jdbc:dataSource id="dataSource"
		db-instance-identifier="myRdsDatabase"
		password="${rdsPassword}" user-tags-map="dbTags" />
----

Allows the developer to access the properties in the code using expression like shown in the class below:

[source,java,indent=0]
----
public class SampleService {

	@Value("#{dbTags['aws:cloudformation:aws:cloudformation:stack-name']}")
	private String stackName;
}
----

[NOTE]
====
The database tag _aws:cloudformation:aws:cloudformation:stack-name_ is a default tag that is created if the
database is configured using CloudFormation.
====

==Sending mails
Spring has an built-in support to send E-Mail based on the http://www.oracle.com/technetwork/java/javamail/index.html[Java Mail API]
to avoid any static method calls while using the Java Mail API and thus supporting the testability of application.
Spring Cloud AWS supports the http://aws.amazon.com/de/ses/[Amazon SES] as an implementation of the Spring Mail abstraction.

As a result Spring Cloud AWS users can decide to use the Spring Cloud AWS implementation of the Amazon SES service or
use the standard Java Mail API based implementation that send mails via SMTP to Amazon SES

[TIP]
====
It is preferred to use the Spring Cloud AWS implementation instead of the SMTP mainly for performance reasons.
Spring Cloud AWS uses one API call to send a mail message, the SMTP protocol makes multiple requests (EHLO, MAIL FROM, RCPT TO, DATA, QUIT)
until it sends an e-mail
====

=== Configuring the mail sender
Spring Cloud AWS provides a XML element to configure a Spring _org.springframework.mail.MailSender_ implementation for the
client to be used. The default mail sender work without a Java Mail dependency and is capable of sending messages without
attachment as simple mail messages. A configuration with the necessary elements will look like this


[source,xml,indent=0]
----
<beans xmlns:aws-mail="http://www.springframework.org/schema/cloud/aws/mail"
   xsi:schemaLocation="http://www.springframework.org/schema/cloud/aws/mail
      http://www.springframework.org/schema/cloud/aws/mail/spring-cloud-aws-mail-1.0.xsd">

	<aws-context:context-credentials>
	  ..
	</aws-context:context-credentials>

	<aws-context:context-region region="EU_WEST_1" />

	<aws-mail:mail-sender id="testSender" />

</beans>
----

=== Sending simple mails
Application developers can inject the _MailSender_ into their application code and directly send simple text based e-mail
 messages. The sample below demonstrates the creation of a simple mail message.

[source,java,indent=0]
----
public class MailSendingService {

	private MailSender mailSender;

	@Autowired
	public MailSendingService(MailSender mailSender){
		this.mailSender = mailSender;
	}

	public void sendMailMessage() {
		SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
		simpleMailMessage.setFrom("foo@bar.com");
		simpleMailMessage.setTo("bar@baz.com");
		simpleMailMessage.setSubject("test subject");
		simpleMailMessage.setText("test content");
		this.mailSender.send(simpleMailMessage);
	}
}
----


=== Sending attachments
Sending attachments with e-mail protocol requires mime messages to be created and sent. In order to create MimeMessages,
the Java Mail dependency is required and have to be included into the classpath. Spring Cloud AWS will detect the
dependency and create a _org.springframework.mail.javamail.JavaMailSender_ implementation that allows to create and
build mime messages and send them. A dependency configuration for the Java Mail api is the only change in the configuration
which is shown below.

[source,xml,indent=0]
----
<dependency>
	<groupId>javax.mail</groupId>
	<artifactId>mailapi</artifactId>
	<version>1.4.1</version>
	<exclusions>
		<!-- exclusion because we are running on Java 1.7 that includes the activation API by default-->
		<exclusion>
			<artifactId>activation</artifactId>
			<groupId>javax.activation</groupId>
		</exclusion>
	</exclusions>
</dependency>
----

[HINT]
====
Even though there is a dependency to the Java Mail API there is still the Amazon SES API used underneath to send mail
messages. There is no http://docs.aws.amazon.com/ses/latest/DeveloperGuide/send-email-smtp.html[SMTP setup] required
on the Amazon AWS side.
====

Sending the mail requires the application developer to use the _JavaMailSender_ to send an E-Mail that is shown in the example
below.

[source,java,indent=0]
----
public class MailSendingService {


	private JavaMailSender mailSender;

    @Autowired
	public MailSendingService(JavaMailSender mailSender){
		this.mailSender = mailSender;
	}

	public void sendMailMessage() {
		this.mailSender.send(new MimeMessagePreparator() {

        			@Override
        			public void prepare(MimeMessage mimeMessage) throws Exception {
        				MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true, "UTF-8");
        				helper.addTo("foo@bar.com");
        				helper.setFrom("bar@baz.com");
        				helper.addAttachment("test.txt", new ByteArrayResource("attachment content".getBytes("UTF-8")));
        				helper.setSubject("test subject with attachment");
        				helper.setText("mime body", false);
        			}
        		});
	}
}
----

=== Configuring regions
Amazon SES is not available in all http://docs.aws.amazon.com/ses/latest/DeveloperGuide/regions.html[regions] of the
Amazon Webservices cloud. Therefore an application hosted and operated in a region that does not support the mail
service will produce an error while using the mail service. Therefore the region must be overridden for the mail
sender configuration. The example below shows a typical combination of a region (EU-CENTRAL-1) that does not provide
and SES service, the client is overridden to usa a valid region EU-WEST-1.

[source,xml,indent=0]
----
<beans ...>

 <aws-context:context-region region="EU_CENTRAL_1" />
 <aws-mail:mail-sender id="testSender"  region="EU_WEST_1"/>

</beans>
----

=== Authenticating E-Mails
To avoid any spam attacks on the Amazon SES mail service, application without production access must
http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html[verify] each
e-mail receiver otherwise the mail sender will throw an _com.amazonaws.services.simpleemail.model.MessageRejectedException_.

http://docs.aws.amazon.com/ses/latest/DeveloperGuide/request-production-access.html[Production access] can be requested
 and will disable the need for mail address verification.

